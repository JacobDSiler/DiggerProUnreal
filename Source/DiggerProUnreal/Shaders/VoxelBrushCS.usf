// /Digger/VoxelBrushCS.usf
RWTexture3D<float> RW_SDF;

cbuffer Params
{
	float3 ChunkOriginWS;
	float  VoxelSize;
	float3 BrushPosWS;
	float  BrushRadius;
	float  BrushFalloff;
	uint   bDig; // 1 dig (air), 0 add (solid)
	int3   BoundsMin;
	int3   BoundsMax; // exclusive
};

// Thread group size (tweak as you like)
[numthreads(8,8,8)]
void CSMain(uint3 DTid : SV_DispatchThreadID)
{
	int3 v = int3(BoundsMin + DTid);
	if (any(v < BoundsMin) || any(v >= BoundsMax)) return;

	// Convert v (0..N-1) to world-space center
	float3 centerLS = (float3(v) - 0.5.xxx * (BoundsMin + BoundsMax)) * VoxelSize; // local offset
	float3 centerWS = ChunkOriginWS + (float3(v) * VoxelSize - 0.5.xxx * (BoundsMax - BoundsMin) * VoxelSize);

	// Simpler: exact center
	centerWS = ChunkOriginWS + (float3(v) + 0.5.xxx - 0.5.xxx * 0 /*un-used*/) * VoxelSize;

	// Distance-based SDF (sphere-like). You can extend with shape logic later.
	float d = distance(centerWS, BrushPosWS);
	float sdfBrush = (d - BrushRadius) / max(BrushFalloff, 0.0001);

	// Read current texel
	float oldSDF = RW_SDF[v];

	// Blend rule: dig → max (toward +1 air), add → min (toward -1 solid)
	float newSDF = bDig != 0 ? max(oldSDF, sdfBrush) : min(oldSDF, sdfBrush);

	RW_SDF[v] = newSDF;
}

// TODO: Add exact modified voxel count
//   -> Implement RWStructuredBuffer<uint> counter in shader
//   -> Increment only when oldSDF != newSDF
//   -> Read back on brush end or at interval for accuracy in FVoxelModificationReport

// TODO: Support all brush shapes on GPU
//   -> Sphere implemented
//   -> Add Cube, Capsule, Cylinder, Cone, Torus, Pyramid, Icosphere, Smooth, Noise
//   -> Share math with CPU UVoxelBrushShape where possible

// TODO: GPU → CPU sync
//   -> On brush end, read back touched region into SparseVoxelGrid for save/serialization
//   -> Optimize with staging buffer and batched updates

// TODO: GPU marching cubes (future)
//   -> Use Res->SDF_SRV to run marching cubes in compute
//   -> Replace CPU mesh extraction for large performance win
